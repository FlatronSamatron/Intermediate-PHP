# PHP intermediate

* [PHP Docker - Nginx](https://www.youtube.com/watch?v=I_9-xWmkh28)

    * Рассматриваются такие понятия как контейнеры, образы, Dockerfile и Docker Compose в контексте среды разработки
      Docker для PHP.

    * Показан простой проект с двумя сервисами - PHP-FPM и Nginx. Используются файлы Dockerfile и docker-compose.yml для
      конфигурирования контейнеров.

    * С помощью docker-compose можно запустить несколько проектов на разных версиях PHP одновременно. Это упрощает
      настройку окружения по сравнению с XAMPP.

    * Также упоминается о дополнительных сервисах как MySQL, о настройке php.ini и нюансах производственной среды.

    *  ### В целом дается представление о Docker для среды разработки PHP-приложений - что такое контейнеры и образы, как писать Dockerfile и docker-compose.yml.

---

* [PHP Classes & Objects - Typed Properties - Constructors & Destructors](https://www.youtube.com/watch?v=6FW72q5fIx8)
    - Класс - это чертеж для создания объектов. Объект - это экземпляр класса.

    - Свойства определяют данные объекта, а методы - его поведение. Видимость может быть публичной, приватной или
      защищенной.

    - Конструкторы инициализируют свойства при создании объекта. Проверка типов для свойств требует их инициализации.

    - Методы могут возвращать объект, чтобы разрешить цепочку вызовов методов. Не все методы должны быть цепочными.

    - Геттеры и сеттеры используются для энкапсуляции доступа к свойствам, когда они приватные.

    - Можно создать несколько объектов одного класса с разными значениями свойств.

    - Деструкторы выполняют очистку при уничтожении объекта. Они редко используются.

    - StdClass может быть использован для генерического создания объектов. Массивы и скалярные типы могут быть
      преобразованы в объекты.

    - Свойства объекта соответствуют ключам массива или значениям скалярного типа при преобразовании.

    - Проверка типов для свойств определяет ожидаемый тип, предотвращая недопустимые назначения.

    - ### В резюме видео рассматриваются ключевые концепции классов, объектов, свойств, методов, конструкторов, цепочного вызова и энкапсуляции в объектно-ориентированном программировании PHP. Показано как определять классы и создавать множественные экземпляры объектов.

---

- [Constructor Property Promotion - Nullsafe Operator](https://www.youtube.com/watch?v=T1PbFz-o6kw)

---

- [PHP Namespace Tutorial](https://www.youtube.com/watch?v=Jni9c0-NjrY)
    - Пространства имен помогают избежать коллизий имен классов, функций и констант, логически группируя взаимосвязанные
      элементы.

    - Ключевое слово namespace используется в верхней части файла для объявления пространства имен. Пространства имен
      могут содержать подпространства для соответствия древовидной структуре каталогов.

    - Без пространств имен элементы по умолчанию попадают в глобальное пространство имен и могут возникнуть коллизии.
      Использование пространств имен решает эту проблему.

    - Классы обращаются к своему полностью квалифицированному имени с разделителем пространств имен либо через импорт
      пространств/классов.

    - Правила разрешения имен - не квалифицированное ищется в локальном пространстве, квалифицированное - по импортам,
      полностью квалифицированное всегда работает.

    - Функции ищутся в глобальном пространстве если не найдены локально, в отличие от классов, которые выдают ошибку.
      Функции могут префиксироваться для обеспечения глобальной области видимости.

    - Псевдонимы позволяют использовать одно и то же имя класса из разных пространств имен, избегая коллизий. Можно
      также полностью переименовать пространство имен.

    - Подключаемые файлы не наследуют импортированные классы/пространства родительского файла, поэтому импорты требуются
      в обоих.

    - ### Это охватывает основные моменты использования пространств имен для избежания коллизий имен, разрешения пространств и классов, а также некоторые лучшие практики работы с namespaces в PHP.

---

- [PHP Coding Standards, Autoloading (PSR-4) & Composer](https://www.youtube.com/watch?v=rqzYdHdyMH0)
    - В PHP есть встроенная функция автозагрузки классов spl_autoload_register, которая позволяет определить
      callback-функцию для автоматической загрузки классов.

    - Внутри функции-обработчика получается полное имя класса, на основании которого необходимо подключить/включить
      соответствующий файл.

    - Composer - это менеджер зависимостей для PHP, который берет на себя автозагрузку и установку внешних
      пакетов/библиотек.

    - Composer генерирует файлы автозагрузки, в которых классы соотносятся с путями к файлам, позволяя автоматически
      загружать классы.

    - В composer.json перечисляются зависимости проекта, которые будут устанавливаться с Packagist.

    - Папка vendor содержит исходный код установленных зависимостей. autoload.php регистрирует автозагрузчик Composer.

    - Стандарты PSR такие как PSR-1 и PSR-12 определяют рекомендации по стилю кода PHP-проектов. PHP CodeSniffer
      проверяет соответствие стилю.

    - Composer может автозагружать классы проекта, если их пространства имен указаны в composer.json и файла
      автозагрузки пересобраны.

    - Классовая карта (classmap) позволяет для оптимизации прямо соотносить все классы с файлами в продакшене.

    - ### То есть в кратце в видео рассказывалось про автозагрузку классов в PHP, использование Composer для управления зависимостями и автозагрузкой, стандарты PSR, настройку PHP-проекта с применением Composer.

---

- [Object Oriented PHP - Class Constants](https://www.youtube.com/watch?v=bEGNvUxYf2o)
    - Константы в PHP определяются с помощью ключевого слова const и должны быть в верхнем регистре с подчёркиваниями.
      Они являются неизменяемыми значениями.

    - Классовые константы можно обращаться с использованием имени класса и оператора разрешения области видимости (::).
      Они выделяются один раз для каждого класса.

    - Константам можно задавать видимость, такую как public или private. Приватные константы можно обращаться только
      внутри класса.

    - Константы удобны для хранения неизменяемых данных, значение которых может меняться, избегая жёсткого кодирования
      значений.

    - Константы в стиле enum можно использовать для представления статусов, ролей и т.д., предотвращая ошибки в
      написании. Они были вынесены из класса Transaction в отдельный класс перечислений Status.

    - Добавлена константа all_statuses в виде массива со статусами в качестве ключей и понятными именами в качестве
      значений для валидации.

    - Упомянуты статические свойства и методы как следующая тема. PHP 8.1 добавит нативную поддержку типа enum для более
      чистого определения классов констант.

    - ### В резюме рассказано о том, как определять, обращаться и использовать классовые константы в PHP, а также некоторых лучших практиках, таких как вынесение их в отдельные классы перечислений для организации и валидации.

---

- [Static Properties & Methods + singletone](https://www.youtube.com/watch?v=6VVN-2SCx7Q)

    - Статические свойства и методы принадлежат самому классу, а не отдельным объектам. Их можно обращаться без создания
      объекта.

    - Чтобы определить статическое свойство/метод, используется ключевое слово static. Свойства можно инициализировать
      как обычные свойства.

    - Статические свойства общедоступны для всех экземпляров класса. Изменение значения в одном месте влияет на все.

    - Для доступа к приватным статическим свойствам изнутри класса используются ключевые слова self или название класса.
      Вне класса могут понадобиться статические геттеры.

    - Типичные случаи использования статиков - счётчики, кэширование, утилитные методы, шаблоны singleton/factory (хотя
      предпочтительнее инъекция зависимостей).

    - Статики представляют глобальное состояние, что ухудшает тестируемость и поддержку. Их следует избегать, кроме
      очень узких случаев.

    - Статические методы могут маскироваться под методы объекта, но не стоит этого делать, так как это скрывает их
      статическую природу.

    - ### В видео показано определение/вызов статических свойств и методов, их общее значение, доступ из класса, вред от неправильного использования статиков.

--- 

- [Encapsulation & Abstraction](https://www.youtube.com/watch?v=kA9BTNPFObo)
    - Инкапсуляция объединяет данные и методы, которые работают с этими данными, в пределах класса. Она скрывает
      внутреннее представление и состояние объекта. Это защищает целостность объекта.

    - Установка свойств как публичных может нарушить инкапсуляцию, позволяя внешнему коду изменять внутреннее состояние
      объекта.

    - Геттеры и сеттеры иногда используются для выставления свойств при одновременном соблюдении инкапсуляции. Однако
      они также могут нарушить инкапсуляцию при чрезмерном использовании.

    - В целом лучше делать свойства приватными и передавать данные через конструктор или методы, а не позволять внешнему
      коду изменять состояние через сеттеры.

    - Абстрагирование скрывает детали реализации, так что пользователям нужно знать только интерфейс (вызываемые
      методы), а не то, как все работает внутри. Это позволяет гибко менять внутреннюю реализацию, не затрагивая внешний
      код.

    - Приватные/защищённые свойства и методы могут быть доступны другим объектам того же класса с помощью рефлексии или
      передачи объектов между методами одного класса.

    - Инкапсуляция сосредоточена на скрытии внутреннего состояния, тогда как абстрагирование — на скрытии деталей
      реализации от пользователей. Оба принципа помогают достичь слабой связанности и лучшего проектирования.

    - ### В целом текст рассматривает инкапсуляцию и абстрагирование как два основных принципа объектно-ориентированного программирования на PHP, акцентируя внимание на то, как их применять для защиты состояния объекта и гибкости реализации.

---

- [Encapsulation & Abstraction](https://www.youtube.com/watch?v=LyyzeYOoH5s)
    - Наследование позволяет дочернему классу унаследовать свойства и методы от родительского класса. Дочерний класс
      расширяет родительский.

    - Унаследованные свойства и методы могут быть переопределены в дочернем классе. Частные свойства недоступны.

    - Конструкторы в дочерних классах не вызываются автоматически, поэтому родительский конструктор должен быть вызван
      явно с помощью parent::construct().

    - Подписи методов должны быть совместимы при переопределении методов. Параметры и типы возвращаемых значений могут
      варьироваться больше в PHP 8.

    - Ключевое слово final предотвращает наследование классов и переопределение методов.

    - Примеры наследования включают типы транзакций, поля форм и типы счетов.

    - Наследование может нарушить инкапсуляцию и привести к наследованию ненужных методов. Переопределение для бросания
      исключений не является идеальным.

    - Композиция предпочтительнее наследования, когда отношение "является" не применимо, как в случае наследования
      духовки от тостера.

    - С помощью композиции класс может содержать другой класс в качестве свойства, а не расширять его. Это было
      продемонстрировано на примере класса роскошной духовки.

    - ### Наследование полезно, когда оно адекватно моделирует взаимоотношения между классами, но композиция следует рассмотреть в качестве альтернативы в других случаях.

---

- [Inheritance](https://www.youtube.com/watch?v=LyyzeYOoH5s)

    - Наследование позволяет дочернему классу унаследовать свойства и методы от родительского класса. Дочерний класс
      расширяет родительский.

    - Унаследованные свойства и методы могут быть переопределены в дочернем классе. Частные свойства недоступны.

    - Конструкторы в дочерних классах не вызываются автоматически, поэтому родительский конструктор должен быть вызван
      явно с помощью parent::construct().

    - Подписи методов должны быть совместимы при переопределении методов. Параметры и типы возвращаемых значений могут
      варьироваться больше в PHP 8.

    - Ключевое слово final предотвращает наследование классов и переопределение методов.

    - Примеры наследования включают типы транзакций, поля форм и типы счетов.

    - Наследование может нарушить инкапсуляцию и привести к наследованию ненужных методов. Переопределение для бросания
      исключений не является идеальным.

    - Композиция предпочтительнее наследования, когда отношение "является" не применимо, как в случае наследования
      духовки от тостера.

    - С помощью композиции класс может содержать другой класс в качестве свойства, а не расширять его. Это было
      продемонстрировано на примере класса роскошной духовки.

    - ### Наследование полезно, когда оно адекватно моделирует взаимоотношения между классами, но композиция следует рассмотреть в качестве альтернативы в других случаях.

---

- [Abstract Classes](https://www.youtube.com/watch?v=UnwaW13xJuw)

---

- [Interfaces & Polymorphism](https://www.youtube.com/watch?v=-AJic0FjuAA)
    - Интерфейс определяет контракт, которому должны соответствовать конкретные классы, реализуя методы интерфейса. Это
      позволяет обеспечить полиморфизм, когда несколько классов могут работать с одним и тем же интерфейсом.

    - Объявление интерфейса создаёт абстрактный шаблон без реализации тел методов. Конкретные классы, реализующие
      интерфейс, должны предоставить реализации методов.

    - Интерфейсы позволяют писать код в зависимости от интерфейса, а не конкретного класса, улучшая гибкость и
      развязывая код от специфических реализаций. Это следует принципу "Программировать по интерфейсу".

    - Проблемы возникают, когда код слишком специфически зависит от конкретных классов-реализаций, а не от интерфейсов.
      Интерфейсы решают эту проблему, позволяя использовать любой класс, соответствующий контракту интерфейса.

    - Пример демонстрирует интерфейс сбора долгов с двумя реализациями - одна использует случайный сбор, другая всегда
      собирает 65%. Код работает с обеими благодаря программированию по интерфейсу.

    - Преимущества интерфейсов включают множественное наследование поведения, поддержку разных реализаций и разделение
      контракта от конкретных классов.

    - Фреймворки часто используют интерфейсы, такие как стандарты PSR, для определения общего поведения компонентов
      кэширования, логгирования и других плагинов, работающих через различные бэкенды.

    - ### Это сжатое изложение основных моментов о интерфейсах, их преимуществах и примерах из видео. Скажите, если какой-то момент нуждается в дополнительном разъяснении.

---

- [2.12 - Magic-Methods](https://www.youtube.com/watch?v=nCxnzj83poQ)
    - Волшебные методы в PHP - это специальные методы, которые переопределяют стандартное поведение для определенных
      действий или событий с объектом. Они начинаются с двойного подчеркивания, как __construct.

    - Распространенные волшебные методы включают:
        - get и set для доступа к несуществующим свойствам
        - isset и unset для проверки существования свойства
        - call и callStatic для вызова несуществующих методов
        - __toString для обработки преобразования объекта в строку

    - Методы get и set позволяют перехватить доступ/назначение свойств и обеспечить обратную совместимость или обработку
      ошибок.

    - isset и unset подключаются к проверке наличия и удалению свойств.

    - call и callStatic перехватывают вызовы методов и позволяют отложенные вызовы для других объектов. Так реализуется
      работа фасадов в Laravel.

    - __toString контролирует преобразование объекта в строку, например при выводе объекта. Начиная с PHP 8, он
      импlicitно реализует интерфейс Stringable.

    - __invoke делает объект прямо вызываемым, полезно для классов с одиночным действием.

    - __debugInfo контролирует выводимые свойства при var_dump для конфиденциальности или уменьшения избыточности.

    - Другие волшебные методы как clone, serialize обрабатывают клонирование и сериализацию объектов.

    - ### В общем, волшебные методы предоставляют «уколы» для типичных действий с объектом и позволяют реализовать мощные возможности, такие как динамические/отложенные свойства, диспетчеризацию методов и преобразование в строку совместимым образом. Они являются ключевыми для фреймворков и добавляют гибкость в поведение объектов PHP.

---

- [2.13 - Late Static Binding](https://www.youtube.com/watch?v=4W5t8g3Rp_0)
    - Позднее статическое связывание относится к тому, как PHP разрешает вызовы классов/методов во время выполнения, а
      не на этапе компиляции.

    - Существует два типа связывания - раннее связывание на этапе компиляции и позднее связывание во время выполнения.

    - Раннее связывание использует ключевое слово self, которое разрешает класс на этапе компиляции. Это вызывает
      проблемы с наследованием.

    - Позднее связывание использует ключевое слово this для разрешения класса во время выполнения на основе контекста
      объекта. Оно сохраняет поведение наследования.

    - Для вызова статических методов и доступа к статическим свойствам с выгодами позднего связывания используется
      ключевое слово static. Оно разрешает исходный класс перед наследованием/перенаправлением.

    - Примеры показывают, что static разрешает подкласс во время выполнения, а не всегда базовый класс как self.

    - Ключевое слово static можно также использовать в нестатических контекстах для имитации разрешения позднего
      связывания для объектов.

    - Начиная с PHP8, static можно использовать в качестве типа возвращаемого значения, чтобы указать на наследуемые
      статические фабричные методы вместо всегда разрешения базового класса.

    - ### В резюме, позднее статическое связывание позволяет наследующим классам переопределять базовые статические методы/свойства ожидаемым образом с использованием ключевого слова static вместо self.

---

- [2.14 - Traits](https://www.youtube.com/watch?v=PMruqUC4Qpc)

    - ### В PHP трейты позволяют совместно использовать методы между классами без наследования. Трейты можно использовать для уменьшения дублирования кода.

    - ### Некоторые ключевые особенности трейтов:

        - В трейтах можно объявлять методы, свойства и константы
        - Классы могут использовать несколько трейтов с помощью инструкции use
        - Видимость методов можно менять при использовании трейта
        - В трейтах можно объявлять абстрактные методы
        - Статические методы и свойства работают независимо в каждом классе, использующем трейт
        - Есть правила приоритета для методов, если класс тоже определяет такой метод
        - Оператор instead of разрешает конфликты имен методов между трейтами

    - ### С трейтами есть некоторые проблемы:
        - Не стоит менять видимость методов или делать приватные методы паблик
        - Финальные и приватные методы не блокируют переопределение как в наследовании
        - Абстрактные методы в трейтах не очень хорошее решение, для контрактов лучше интерфейсы.

    - ### Хороший применение - общий метод отправки электронной почты между несвязанными классами Покупатель и Счет. Трейты избегают дублирования кода и неправильного использования наследования в этом случае.

    - ### В целом, трейты полезны для повторного использования кода, но главным образом для избежания дублирования, а не как замена наследованию или интерфейсам. Их мощности нужно использовать ответственно.

---

- [2.15 - Anonymous Classes](https://www.youtube.com/watch?v=zQ4Znj3RT3E)
    - Анонимные классы - это классы, определенные без имени. Их можно создать, используя ключевые слова new и class.

    - В анонимных классах можно задать конструктор с аргументами, определить свойства и методы, реализовать интерфейсы,
      расширить другие классы и т.д. точно как в обычных классах.

    - Основное применение анонимных классов - тестирование, в частности создание мок-зависимостей. Они позволяют
      создавать мок-объекты без отдельного класса.

    - Анонимные классы избегают обращения к загрузчику, так как определяются непосредственно без имени файла. Это дает
      микро-оптимизацию.

    - Использование анонимных классов вне области их определения также является плюсом, так как не загрязняет глобальную
      область видимости.

    - Хотя анонимные классы формально не имеют имени, PHP динамически ему назначает. Но нужно считать, что имени нет и
      их нельзя указывать в типизации. Для этого используются интерфейсы.

    - Анонимные классы внутри других классов не могут обращаться к свойствам и методам вмещающего класса, если только
      через конструктор или наследование.

    - ### В целом, анонимные классы позволяют непосредственно определять простые классы без имени, в первую очередь для тестовых моков, при сохранении обычных возможностей классов, таких как наследование, свойства, интерфейсы.

---

- [2.16 - Object Comparison](https://www.youtube.com/watch?v=zCGmZb3z-r8)
    - Сравнение объектов в PHP с использованием операторов сравнения == и ===. == проверяет значения свойств
      объектов, === - идентичность объектов.

    - Различия между присваиванием и ссылками на объекты. При присваивании объектов копируются ссылки, а не сами
      объекты.

    - Хранение переменных и объектов в PHP. Переменные хранят указатели на структуру данных zval, где хранятся значения.
      Для объектов zval хранит указатель на объект.

    - Сравнение вложенных объектов. Сравнение происходит рекурсивно, учитываются значения вложенных свойств.

    - Опасность циклических ссылок между объектами при их сравнении. Может вызвать ошибку.

    - Демонстрация работы === и == на практических примерах с разными классами объектов.

---

- [2.17 - DocBlock](https://www.youtube.com/watch?v=hdDD0SNJ-pk)
    - Docblocks предоставляют документацию для кода путем использования структурированных комментариев над классами,
      методами, функциями, свойствами и т.д.

    - Общие теги включают @param для параметров, @return для типа возвращаемого значения, @throws для исключений.

    - Типы могут указываться с помощью тегов типа @param Customer $customer

    - Тег @var указывает типы переменных, свойств и констант.

    - Теги @property и @method помогают подсказывать магические методы и свойства.

    - Docblocks не валидируются, но их можно обрабатывать инструментами для генерации документации.

    - Преимущества - подсказки, стандартизированная документация, возможность указывать сложные типы.

    - Недостатки - избыточные комментарии, могут указывать на плохой дизайн кода.

    - В PHP есть поддержка типизации, которая обеспечивает аналогичную функциональность без docblocks.

    - Предпочтения разнятся, многие разработчики теперь используют docblocks только при необходимости из-за лучшей
      типизации в PHP.

    - Docblocks по-прежнему полезны для описания сложной логики или неочевидных аспектов кода.

    - ### В резюме кратко описаны основные элементы docblocks в PHP - назначение, структура и распространенные теги согласно предоставленному тексту. Сообщите, если требуется разъяснить или расширить какую-либо часть.

---

- [2.18 - Object Cloning](https://www.youtube.com/watch?v=vLmIoy6Bnog)

    - Существует несколько способов создавать объекты в PHP. Самый распространенный — использование ключевого слова new
      за которым следует название класса. Также можно использовать new с ключевыми словами self или static. Объекты
      могут создаваться из других объектов с помощью new над самим объектом.

    - В видео демонстрируется создание объектов в классе Invoice. Клонирование объектов присваивает тот же объект другой
      переменной, но обе переменные указывают на один и тот же объект в памяти. Изменение одного приведёт к изменению
      другого.

    - Чтобы действительно склонировать объект, нужно использовать ключевое слово clone. Это выполняет поверхностную
      копию, дублируя свойства, но результатом будут два разных объекта.

    - Магический метод clone выполняется при клонировании и может изменять значения свойств перед возвратом клона. Это
      позволяет например назначить новый ID. Конструктор не вызывается при клонировании, но clone позволяет произвести
      послеклоновую очистку или инициализацию.

    - ### В резюме были рассмотрены основные способы создания объектов в PHP и как клонировать объекты, а не просто присваивать ссылки, с примерами использования класса Invoice.

---

- [2.19 - Object Serialization](https://www.youtube.com/watch?v=Jnm2m_Iw5CI)

    - Сериализация - это преобразование значения в строковый формат для хранения или передачи. Можно сериализовать любое
      значение в PHP, кроме ресурсов и замыканий.

    - Функция serialize сериализует значение, функция unserialize десериализирует обратно. При сериализации объектов
      сохраняются свойства и значения, но не методы.

    - Для изменения способа сериализации/десериализации объектов используются магические методы:

        - sleep() / wakeup() - вызываются перед/после сериализации, позволяют фильтровать сериализуемые свойства.

        - serialize()/unserialize() (PHP7.4+) - более удобная альтернатива, позволяют полную настройку
          сериализации/десериализации. Метод serialize() должен вернуть массив для сериализации, unserialize()
          восстанавливает объект.

    - Таким образом можно реализовать шифрование/дешифрование значений, восстановление зависимостей и т.д.

- ### Сериализация используется для хранения объектов в БД, файле или их передачи. При воссоздании объекта получается его новая копия с идентичными свойствами.

---

- [2.20 - Exceptions](https://www.youtube.com/watch?v=XQ5Pd-6Hnjk)

    - Исключения в PHP позволяют грамотно обрабатывать ошибки вместо прерывания скрипта. Они могут выбрасываться вручную
      или
      в результате ошибок во встроенных функциях/коде.

    - Класс Exception является базовым классом для всех исключений. Специфические классы исключений как
      InvalidArgumentException наследуются от него.

    - Исключения можно перехватывать с помощью блоков try-catch. Блок catch обрабатывает исключение и позволяет
      продолжить
      выполнение скрипта.

    - Блок finally всегда выполняется независимо от того, было ли исключение перехвачено или нет. Значения возвращаются
      после выполнения finally блоков.

    - Для более специфических типов исключений могут создаваться пользовательские классы исключений, которые должны
      наследоваться от базового класса Exception.

    - Сообщения об ошибках определяются как свойства класса, чтобы избежать дублирования. Статические методы могут
      выступать
      в роли фабрик исключений.

    - Глобальная функция обработки исключений set_exception_handler() позволяет обрабатывать все неперехваченные
      исключения.

    - Исключения предоставляют более надёжный способ обработки ошибок, чем прерывание скриптов. Они позволяют грамотно
      обрабатывать ошибки и продолжать выполнение кода там, где это возможно.

    - ### Выбрасывание исключений рекомендуется для экстремальных ситуаций, в то время как обычные ошибки лучше обрабатывать с помощью возвращаемых значений.

---

- [2.21 - DateTime Object](https://www.youtube.com/watch?v=hkTQkaFzEEo)

    - PHP предоставляет объекты DateTime для работы с датами и временем объектно-ориентированным способом. Объекты
      DateTime можно создать, передав строку с датой/временем или отдельные компоненты даты/времени.

    - Методы как setDate(), setTime(), add(), sub() позволяют изменять объекты DateTime. Форматирование можно делать с
      помощью format(). Временные пояса можно устанавливать/менять используя setTimezone().

    - Объекты DateTimeImmutable предоставляют неизменяемую альтернативу, которая создает новые объекты при модификации,
      а не изменяет существующий.

    - Класс DateInterval представляет период времени, который можно добавлять/вычитать из объектов DateTime.

    - Класс DatePeriod итерируется по периоду, определенному стартовой датой, интервалом и конечной датой/количеством
      повторений.

    - Форматирование интервалов дат с использованием % спецификаторов позволяет получать читаемый текст.

    - Операторы сравнения и метод diff() позволяют сравнивать объекты DateTime.

    - Для изменения скопированных объектов DateTime нужно использовать clone(), чтобы избежать ссылок.

    - Carbon - это расширение PHP, которое предоставляет удобный API для работы с датами/временем.

    - ### В общем, в видео было продемонстрировано создание, изменение, форматирование, сравнение и итерацию по датам/времени с использованием основных классов PHP DateTime и общих методов.

---

- [2.22 - Iterable Data Type & Iterators](https://www.youtube.com/watch?v=QFPP9B-Q3zM)

    - В PHP по умолчанию можно проходить итерацию по объектам с помощью цикла foreach, но это работает только для
      публичных свойств.

    - Чтобы итерироваться по конкретным свойствам или собственным способом необходимо, чтобы классы реализовывали
      интерфейсы Iterator или IteratorAggregate.

    - Интерфейс Iterator требует реализации методов типа current(), next(), key() и т.д. Это дает полный контроль над
      итерацией.

    - IteratorAggregate требует лишь метода getIterator() для возврата итератора. Это проще, но меньший контроль.

    - Встроенные SPL итераторы как ArrayIterator могут использоваться через IteratorAggregate для обычных случаев как
      массивы.

    - Был создан базовый класс Collection для вынесения общей логики итератора и возможности расширения таких классов
      как InvoiceCollection.

    - Типизация методов принимающих итерируемые объекты использует псевдотип "iterable" введённый в PHP 7.1 для
      поддержки массивов, коллекций и любых итерируемых.

    - Реализация итераторов позволяет осуществлять ленивую загрузку и уменьшать объём памяти благодаря техникам как
      генераторы.

    - ### Таким образом в сумме рассматривается как сделать классы итерируемыми в PHP через реализацию интерфейсов итератора, использование встроенных итераторов, вынесение общей логики в базовый класс коллекции и типизацию принимающих итерируемые объекты.

---

- [2.23 - Superglobals - Basic Routing Using $_SERVER Info](https://www.youtube.com/watch?v=CF7Yy5cPFVM)

    - Суперглобальные переменные доступны во всех областях видимости PHP-кода. К ним относятся $_GET, $_POST, $_
      FILES, $_COOKIE, $_SESSION и $_SERVER.

    - Суперглобальная переменная $_SERVER содержит информацию о заголовках, путях и местоположениях скриптов. Она может
      предоставить домашний каталог, имя скрипта, URI-запроса, метод запроса, строку поиска, IP-адрес клиента и другие
      сведения.

    - Одно из применений $_SERVER - создание базовой системы маршрутизации, когда разным путям URL могут соответствовать
      разные скрипты или методы.

    - В видео демонстрируется создание простого класса Router для регистрации маршрутов и сопоставления их с
      callback-функциями или комбинациями класс/метод.

    - Метод resolve() разбирает URI-запрос из $_SERVER для определения соответствующего зарегистрированному маршруту и
      выполняет связанное действие.

    - Действия могут быть вызовами callback-функций или массивами с именем класса и метода. Роутер проверяет тип и либо
      вызывает callback напрямую, либо создает класс и вызывает метод.

    - Данный пример демонстрирует основные принципы маршрутизации простым способом. Реальное приложение скорее всего
      будет использовать контроллеры и дополнительные возможности маршрутизации.

    - ### Видео описывает суперглобальную переменную PHP $_SERVER и показывает, как ее можно использовать для реализации простой системы маршрутизации для сопоставления URL-путей с выполнением скриптов. Это помогает проиллюстрировать концепции маршрутизации простым способом.

---

- [2.24 - Superglobals - $_GET/$_POST - Forms](https://www.youtube.com/watch?v=JdrvETQCAGw)

    - В PHP есть глобальные переменные $_GET и $_POST для доступа к данным, переданным в GET и POST запросах. $_REQUEST
      включает данные из GET, POST и cookies.

    - GET запросы извлекают данные с сервера и добавляют параметры в строку запроса URL. POST запросы
      отправляют/сохраняют данные и скрывают их из URL.

    - Формы обычно используют POST для отправки данных таких как вход в систему, покупки. GET используется для
      отображения/фильтрации данных таких как результаты поиска.

    - Маршрутизация была настроена только для поддержки GET, но была улучшена для также поддержки POST путем регистрации
      маршрутов для разных методов запросов.

    - Форма создания рендерится для маршрута invoices/create, которая POSTит данные на тот же маршрут. Метод store затем
      обрабатывает данные POST.

    - Класс маршрутизатора был обновлен для принятия методов запросов в качестве ключей для получения правильного метода
      обработки на основе GET или POST.

    - ### Глобальные переменные, улучшенная маршрутизация и разделение ответственности такие как рендеринг формы и обработка данных помогают поддерживать разные типы запросов в PHP приложении.

---

- [2.25 - Superglobals - Sessions & Cookies - Output Buffering](https://www.youtube.com/watch?v=6vM-9ou1ARo)

    - Сессии и фикуки используются для поддержания состояния между HTTP-запросами в PHP, так как запросы по умолчанию
      бестосостояние.

    - Сессии хранятся на сервере, в то время как фикуки хранятся на клиенте. Сессии удаляются при закрытии браузера по
      умолчанию, в то время как фикуки истекают в соответствии с установленной датой истечения срока действия.

    - Для использования сессий необходимо вызвать session_start() до вывода любого контента. Буферизация вывода
      позволяет предотвратить ошибки, буферизуя вывод.

    - ID сессии хранится в фикуке, который отправляется с каждым запросом для идентификации данных сессии.

    - Мы можем получать доступ и модифицировать данные сессии с помощью глобальной переменной $_SESSION.

    - Фикуки используются для хранения информации на стороне клиента. Для создания фикуки используется функция
      setcookie().

    - Фикуки необходимо устанавливать до любого вывода, чтобы избежать ошибок. Мы получали доступ к фикукам через
      глобальную переменную $_COOKIE.

    - Чувствительные данные не должны храниться в фикуках из-за рисков безопасности. Фикуки можно удалить, установив
      время истечения срока действия в прошлом.

    - На вывод может влиять буферизация вывода, конфигурация веб-сервера и другие факторы.

    - ### Сессии и куки важные инструменты для поддержания состояния и идентификации пользователя, особенно для аутентификации.

---

- [2.26 - Superglobals - $_GET/$_POST - Forms](https://www.youtube.com/watch?v=JdrvETQCAGw)

    - Загрузка файлов в PHP относительно проста с использованием формы с input файла и отправкой на обработку методом
      контроллера.

    - Файлы временно хранятся, информация о загруженных файлах доступна в глобальной переменной $_FILES в виде
      ассоциативного массива.

    - Для загрузки файлов требуется установить тип кодирования формы multipart/form-data.

    - Необходима валидация на стороне сервера для разрешения только определенных типов, размеров файлов и т.д.

    - Функция move_uploaded_file() может использоваться для перемещения файла изо временной директории в постоянное
      хранение локально или в облаке.

    - Директивы PHP ini как upload_tmp_dir, upload_max_filesize, max_file_uploads и max_input_time контролируют
      настройки загрузки файлов.

    - Можно загружать несколько файлов или массив файлов используя квадратные скобки в именах input.

    - PathInfo может предоставить дополнительную информацию о путях загруженных файлов после перемещения.

    - ### В сумме текст рассматривает работу с загрузкой файлов в PHP, работу с $_FILES, валидацию, перемещение файлов и соответствующие директивы PHP ini.

---

- [2.27 - Intro to MVC](https://www.youtube.com/watch?v=QiO0uUwOiBg)

    - MVC означает Модель-Представление-Контроллер и разделяет слои данных приложения, бизнес-логики и представления.

    - Запрос сначала поступает в контроллер. Затем контроллер взаимодействует с моделью для обработки бизнес-логики
      и данных и с видом для отображения представления.

    - Модель управляет данными приложения и хранилищем данных, таким как база данных. Она может извлекать, хранить и
      обрабатывать данные.

    - Вид отображает представление, такое как HTML. Виды взаимодействуют с контроллерами для отображения данных
      пользователю.

    - Контроллеры обрабатывают запросы, ответы и ресурсы. Они обеспечивают взаимодействие между моделями и видами.

    - MVC может реализовываться по-разному, например модели могут взаимодействовать напрямую с видами или
      использовать маршрутизаторы. Фреймворки как Laravel также добавляют свои собственные реализации на основе MVC.

    - Валидация лучше выносить в отдельный слой от контроллеров, например классы форм запросов, чтобы контроллеры
      были минимальными.

    - ### В видео продемонстрирована реализация базового шаблона MVC на PHP с контроллерами, моделями и видами, передачей данных между ними и рендерингом представлений. Это дало простой пример работы основных концепций MVC.

---

- [2.28 - HTTP Headers In PHP - Request & Response Headers](https://www.youtube.com/watch?v=W7tj0Qlk3rE)

    - HTTP - это протокол для общения между клиентом (браузером) и сервером. Он использует запросы и ответы со
      стандартным форматом сообщения.

    - Запросы и ответы содержат начальную строку, заголовки и тело. Начальная строка идентифицирует метод запроса/URL
      или код ответа.

    - Распространенные заголовки включают Accept, Content-Type, Location, Set-Cookie. Заголовки предоставляют метаданные
      о запросе/ответе.

    - Коды ответа указывают статус ответа, такие как 200 для OK, 301 для Moved Permanently, 404 для Not Found, 500 для
      Internal Server Error.

    - В PHP можно отправлять заголовки с помощью функции header(). Заголовки должны быть отправлены до любого вывода.

    - Исключения могут перехватываться и отображаться страницы ошибок, например 404. Код ответа также должен
      устанавливаться.

    - Заголовки такие как Location и Content-Disposition могут перенаправлять пользователей или инициировать скачивание
      файлов. После заголовков нужно использовать exit для предотвращения дальнейшего выполнения скрипта.

    - Хорошо спроектированные приложения используют классы запросов и ответов для чистого разделения, а не прямые вызовы
      заголовков. Существующие PHP-пакеты предоставляют это.

    - ### В видео основное внимание уделяется ключевым концепциям HTTP, таким как формат запроса/ответа, общие заголовки и коды состояния, а также тому, как PHP может отправлять заголовки и обрабатывать ошибки/перенаправления.

---

- [2.29 - Intro to MySQL](https://www.youtube.com/watch?v=mSnte-Ovm10)

    - MySQL - это реляционная система управления базами данных, которая часто используется с веб-приложениями PHP для
      хранения и извлечения данных.

    - Для локальной разработки используется Docker для запуска контейнера MySQL. Таблицы, данные и пользователи могут
      управляться через командную строку MySQL, MySQL Workbench или аналогичные инструменты.

    - Рассматриваются основы MySQL, включая создание таблиц, вставку/обновление/удаление данных и отбор данных с помощью
      выражений WHERE, ORDER BY, LIMIT и др.

    - Объясняются типы данных как INT, VARCHAR, DATETIME. Также затрагиваются первичные ключи, автоинкрементные ID,
      индексы.

    - Определяются взаимосвязи между таблицами с помощью внешних ключей. Создается таблица invoices с внешним ключом,
      связывающим user_id с таблицей users.

    - Демонстрируется использование JOIN для извлечения данных из связанных таблиц, избегая двусмысленности столбцов за
      счет предварения таблицами.

    - ### Видео знакомит зрителя с основами MySQL перед подключением ее к PHP в дальнейших видео для построения и запросов базы данных полного приложения. Рассматриваются, но не детально более продвинутые темы.
    - docker-compose up -d --build

```
USE my_db;

CREATE TABLE users (
	id INT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
	email VARCHAR(255) UNIQUE NOT NULL,
	full_name VARCHAR(255) NOT NULL,
	is_active BOOLEAN DEFAULT 0 NOT NULL,
	created_at DATETIME NOT NULL,
	KEY `is_active`(`is_active`)
)
```

```
USE my_db;

CREATE TABLE invoices (
	id INT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
	amount DECIMAL(10, 4),
	user_id INT UNSIGNED,
	FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE SET NULL ON UPDATE CASCADE 
)

```

---

- [2.30 - Intro to MySQL](https://www.youtube.com/watch?v=mSnte-Ovm10)

    - PDO (PHP Data Objects) - это слой абстракции баз данных, который позволяет получить доступ к различным системам
      баз данных единообразным способом. Он обеспечивает подготовленные запросы и связывание параметров для
      предотвращения инъекции SQL.

    - Для подключения к базе данных с помощью PDO необходимо создать новый объект PDO, передав в него DSN (имя источника
      данных), имя пользователя и пароль. Это открывает подключение к базе данных.

    - Подготовленные запросы выполняются один раз, но могут выполняться несколько раз с различными параметрами, улучшая
      производительность по сравнению с прямыми запросами. Они защищают от инъекции SQL путем разделения кода и данных.

    - В подготовленных запросах вместо вводимых данных используются плейсхолдеры или именованные параметры. Значения
      вводимых данных связываются отдельно от SQL-запроса.

    - Эмулируемые подготовленные запросы не обеспечивают такого же уровня защиты, поэтому атрибут PDO "
      emulate_prepared_statements" должен быть установлен в false.

    - Транзакции позволяют группировать SQL-инструкции, которые будут either коммититься или откатываться атомарно. Это
      гарантирует согласованность базы данных.

    - Реквизиты подключения к базе данных должны храниться в переменных окружения или конфигурационных файлах безопасным
      образом, а не жестко кодироваться в коде.

    - ### По паттерну MVC логика работы с базой данных и моделями должна быть вынесена из контроллеров в реусабельные классы моделей.

---

- [2.31 - Transactions - Env Variables](https://www.youtube.com/watch?v=e6yLUvpcOZo)

---

- [2.32 - PDO Part 3 - Models & Refactoring](https://www.youtube.com/watch?v=iCKzIIE4w5E)

    - Код был переделан в соответствии с лучшими практиками, такими как разделение ответственности и принцип
      единственной ответственности.

    - Был создан новый класс App для начала работы приложения. Он отвечает за подключение к базе данных и маршрутизацию
      запросов.

    - Подключение к базе данных было перемещено в класс DB с синглтоном, чтобы обеспечить единственное подключение.

    - Были созданы модели для сущностей Пользователь, Счет и процесса регистрации. Они включают в себя логику работы с
      базой данных.

    - Базовый класс Model обеспечивает доступ к подключению б базе данных. Модели расширяют его.

    - Контроллер очищен перемещением бизнес-логики в соответствующие модели.

    - Класс Config обеспечивает значения конфигурации из переменных окружения.

    - Магические методы как __get() позволяют гибко извлекать свойства конфигурации.

    - Тестирование компонентов не рассматривалось, но рефакторинг улучшает тестируемость изолированных компонентов.

    - Представления обновлены для вывода данных из контроллеров и моделей.

    - ### В резюме, структура кода была улучшена и переделана в соответствии с лучшими практиками для повышения поддерживаемости, читабельности и разделения ответственностей через использование классов, наследования и внедрения зависимостей.

---

# Advanced PHP

- [3.0 - Intro to Testing](https://www.youtube.com/watch?v=hTACGV_LdqE)

    - В видео представлены темы, которые будут рассмотрены в третьем разделе серии уроков по PHP, включая такие
      продвинутые темы как тестирование, внедрение зависимостей, API, кэширование, безопасность и создание
      полнофункционального проекта.

    - Тестирование важно для создания приложений и добавления новых функциональностей, так как это помогает выявлять
      ошибки и предотвращать регрессии при рефакторинге кода. Полезно писатьunit- и интеграционное тестирование.

    - Юнит-тесты проверяют, что небольшие части кода работают так, как ожидается, в изоляции, без зависимостей.
      Интеграционные тесты проверяют, что модули работают вместе так, как ожидается.

    - Для тестирования будет использоваться PHPUnit. Юнит-тесты проверяют изолированный код, в то время как
      интеграционные тесты соединяют модули и зависимости.

    - Кратко рассмотрены TDD и BDD. В TDD тесты пишутся перед кодом, а в BDD - описываются поведения на обычном языке. В
      обоих случаях тесты пишутся перед кодом.

    - ### Акцент был сделан на важности тестирования, несмотря на то, что TDD может не всегда быть применимым на практике. Главное - писать тесты, даже если после кода, лишь бы тестирование было.

---

- [3.1 - Unit Testing - PHPUnit Part 1](https://www.youtube.com/watch?v=9-X_b_fxmRM)
    - `path src> ./vendor/bin/phpunit`
    - `composer dump-autoload`

    - В видео показано, как писать юнит-тесты для простого класса роутера в PHP с помощью PHPUnit.

    - Написано несколько тестов для протестирования различных частей роутера, таких как регистрация маршрутов,
      разрешение маршрутов и выброс исключений.

    - Используются такие техники, как data providers, для тестирования нескольких кейсов в одном тесте. Анонимные классы
      используются для имитации зависимостей классов.

    - Показаны методы настройки и сбора, которые позволяют разделить общую настройку между тестами.

    - Обсуждается важность описательного найменования тестов и следования рекомендациям, таким как Arrange-Act-Assert.

    - Показана конфигурация PHPUnit через phpunit.xml и автозагрузку для корректной загрузки классов тестов.

    - Рекомендуется использовать утверждения assertSame вместо assertEquals для избежания ложно-положительных
      результатов из-за нестрогих сравнений.

    - Упоминаются дополнительные темы, такие как организация тестов, даблы, мокинг и заглушки, которые будут рассмотрены
      в будущих видео.

    - ### Целью является написание всеобъемлющих юнит-тестов для роутера для раннего обнаружения ошибок во время рефакторинга благодаря тест-драйвенному подходу. Подчёркивается важность тестирования даже простых классов.

---

- [3.2 - Mocking - PHPUnit Part 2](https://www.youtube.com/watch?v=EhkeoV8nfCQ)

    - Юнит-тестирование позволяет тестировать классы/методы в изоляции, без зависимостей. Для этого используются
      заменители в виде стабов и моков.

    - Стабы/моки позволяют заменить реальные зависимости на поддельные. Это позволяет избежать реальных API-запросов,
      обращения к базе данных и т.п. во время тестирования.

    - В качестве примера используется класс службы счетов, у которого есть зависимости от службы налогообложения,
      платежного шлюза и email-сервиса.

    - Создаются мок-объекты для этих зависимостей с помощью метода createMock(). Их методы возвращают предопределённые
      значения.

    - Изначально тесты проходят случайно или падают из-за вызова реальных медленных методов зависимостей. Моки
      исправляют это.

    - Используется внедрение зависимостей, чтобы передавать моки вместо реальных классов. Это упрощает тестирование.

    - Можно задавать ожидания от моков, например ожидать вызов send() с конкретными аргументами.

    - Тесты проверяют успешную обработку счёта и отправку email, как ожидается.

    - Хорошо протестированный изолированный код с моками ведёт к лучшей проектной структуре и облегчению рефакторинга.

    - Тесты должны падать при неожиданных изменениях кода, например несоответствии аргументов.

    - ### Главный посыл в том, как писать изолированное юнит-тестирование для классов с зависимостями с использованием заменителей в виде стабов и моков в PHPUnit. Это делает тестирование предсказуемым и независимым от внешних систем.

---

- [3.3 - Dependency Injection & DI Containers](https://www.youtube.com/watch?v=igx3bIl1T_c)

    - ### В видео рассматриваются внедрение зависимостей и контейнеры внедрения зависимостей. Он объясняет, что такое внедрение зависимостей, какую проблему оно пытается решить, инвертируя управление и передавая зависимости через инъекцию конструктора. Это делает код более тестируемым и слабосвязанным. Он обсуждает различные типы ВЗ и как он был реализован в примере класса инвойс-сервис. Однако выше по коду есть проблемы с жесткой связностью. Контейнеры внедрения зависимостей помогают решить эту проблему, управляя инициализацией классов и разрешением зависимостей. Контейнер берет на себя инициализацию классов и их зависимых классов. Видео заканчивается тем, что в последующих видео будут рассмотрены реализация простого контейнера ВЗ, автоподключение, API рефлексии и работа контейнеров в Laravel.

---

- [3.4 - DI Container With & Without Reflection API](https://www.youtube.com/watch?v=78Vpg97rQwE)

    - В видео реализуется базовый контейнер внедрения зависимостей (DI) на PHP для демонстрации работы DI.

    - Используется стандарт PSR-11 для определения необходимых интерфейсов контейнера.

    - Класс контейнера хранит связи в массиве entries и соответственно реализует методы get() и has().

    - Добавляется автоподключение для разрешения классов без явных связей с помощью рефлексии для интроспекции
      зависимостей класса.

    - Метод резолвера рекурсивно разрешает зависимости класса путем инспектирования параметров конструктора и разрешения
      любых зависимостей класса.

    - Обрабатываются исключения для случаев отсутствия типизации, неконкретных классов, объединенных типов и т.д.

    - Контейнер проверяется получением объекта InvoiceService с зависимостями.

    - Код затем дорабатывается для инъекции зависимостей в конструктор контроллера путем получения из контейнера.

    - Это демонстрирует как контейнер DI может убрать жесткую привязку классов и сделать их более слабосвязанными и
      тестируемыми.

- ### В резюме видео создает базовый PHP контейнер DI для демонстрации концепций инъекции зависимостей и автоподключения посредством рефлексии и рекурсии для разрешения зависимостей класса.

---

- [3.5 - DI Container With Interface Support](https://www.youtube.com/watch?v=0YDRQbgHBO8)

    - В видео рассматривается реализация поддержки интерфейсов в контейнере DI. В настоящее время он может инъектировать
      только конкретные классы, но не интерфейсы.

    - Создается интерфейс PaymentGatewayInterface. Сервис InvoiceService хочет инъецировать этот интерфейс в качестве
      зависимости, а не конкретный класс.

    - Для поддержки этого в контейнере необходимо настроить связывания, чтобы сказать ему, какой конкретный класс
      использовать при запросе интерфейса. Это делается путем связывания PaymentGatewayInterface с
      PaymentGatewayService.

    - Это позволяет другим классам зависеть от интерфейса, а не от конкретной реализации. Если бэкенд необходимо
      изменить (например, с Stripe на Paddle), достаточно изменить только связывание, не все зависящие классы.

    - Использование интерфейсов способствует слабой связанности и делает код более поддерживаемым и расширяемым со
      временем. Это избегает тесной привязки к конкретной реализации, такой как Stripe.

    - Рекомендуется написать тесты для класса контейнера DI. Приводятся примеры таких упражнений, как чтение кода
      контейнера Laravel и написание юнит-тестов для базового контейнера.

    - ### В резюме, в видео рассматривается, как реализовать поддержку интерфейсов в контейнере DI для повышения гибкости и способности изменять зависимости в будущем. Подчёркиваются преимущества программирования через интерфейсы.

---

- [3.6 - Generators](https://www.youtube.com/watch?v=xH3snMmgDWg)

    - Генераторы - это функции, которые могут возвращать множественные значения вместо единственного. Это позволяет
      итерироваться по большим наборам данных, не загружая все данные в память сразу.

    - Ключевое слово yield используется внутри функций-генераторов для возврата значений. Выполнение приостанавливается
      на каждом yield и возобновляется на следующей итерации.

    - Функции-генераторы возвращают объект генератора, который реализует интерфейс Iterator. Это позволяет итерироваться
      по нему с помощью foreach или получать значения с next()/current().

    - Примеры демонстрируют, как генераторы можно использовать для ленивой обработки больших диапазонов без расхода
      памяти, получения строк из базы данных по одной, и обхода ограничений PHP по памяти.

    - Создание генератора включает написание функции с указанием yield вместо return. Yield возвращает значения по
      одному, вместо создания массива.

    - Преимущества - снижение расхода памяти и возможность итерироваться по огромным наборам данных. Недостатки - нельзя
      перемотать или повторно использовать генератор после первой итерации.

    - Генераторы полезны для ленивой загрузки данных, пагинации, обработки больших файлов построчно и других задач,
      требующих много памяти при итерациях по данным.

    - ### В резюме видео объясняет, что такое генераторы в PHP, как определять и использовать функции-генераторы, и приводит примеры для иллюстрации их преимуществ при итерировании по большим последовательностям без расхода избыточной памяти.

---

- [3.7 - WeakMap](https://www.youtube.com/watch?v=zDKnI_YKCDc)

    - В видео рассматриваются weak map (слабые ассоциативные массивы), которые были введены в PHP 7.4. В слабых массивах
      объекты могут использоваться в качестве ключей, но это не увеличивает ссылочный счет объекта. Это значит, что если
      единственной ссылкой на объект является ключ в слабом массиве, объект будет очищен от памяти при снятии.

    - Слабые массивы полезны для кэшей, где процессинг запускается только так долго, как жив объект. В отличие от spl
      object storage, который создает жесткие ссылки и мешает очистке памяти, слабые массивы используют слабые ссылки,
      поэтому объекты будут удаляться из массива и очищаться из памяти при снятии.

    - ### В видео продемонстрировано создание слабого массива, добавление в него объекта счета в качестве ключа с сопутствующими данными, и то, как при снятии счета он удаляется из массива и очищается. Несколько заметок: в качестве ключей могут использоваться только объекты, элементы нельзя добавить, попытка получить доступ к несуществующему ключу вызовет исключение. Слабые массивы полезны для кэширования, предотвращения утечек памяти и связывания дополнительных данных с объектами без изменения самих объектов.

---

- [3.8 - New In PHP 8.1](https://www.youtube.com/watch?v=cO6i_4n2iwA)

    - PHP 8.1 представил новые возможности, такие как разбор массивов со строковыми ключами, перечисления, свойства
      только для чтения, пересечение типов, тип возврата "never" и синтаксис первоклассных вызываемых функций.

    - Также добавлена новая функция array_is_list() для проверки, является ли массив списком.

    - Несовместимые изменения включают разделение статических переменных в наследуемых методах и возврат чисел и чисел с
      плавающей точкой из PDO в виде внутренних типов даже при включенной эмуляции.

    - Реализация Serializable без serialize/unserialize и неявные преобразования float в int с потерей точности теперь
      отмечены как устаревшие.

    - В видео показано установка PHP 8.1 с Docker, приведены примеры новых возможностей, подчеркнуты несовместимые
      изменения и упомянуты другие ресурсы с подробностями об изменениях.

    - Подробнее рассмотрены такие ключевые нововведения, как перечисления в качестве альтернативы константам классов,
      свойства только для чтения вместо геттер-методов и пересечение типов для методов, требующих нескольких
      интерфейсов.

    - ### Ведущий подчеркнул возможность немедленного использования функций PHP 8.1 и то, что будущие видео в серии также будут использовать PHP 8.1.

---

- [3.9 - New In PHP 8.1](https://www.youtube.com/watch?v=cO6i_4n2iwA)

    - В видео рассматриваются ковариантность и контравариантность в PHP. Ковариантность позволяет переопределять методы
      с
      более специфичными типами возвращаемых значений, например метод класса Собака возвращает объект Собака вместо
      животного в интерфейсе. Контравариантность позволяет переопределять методы с более широкими типами параметров,
      например метод Собаки принимает любой объект Пища вместо конкретно объекта ПищаЖивотного.

    - PHP поддерживает ковариантность для типов возвращаемых значений и контравариантность для параметров начиная с
      версии
      7.4. Предыдущие версии генерировали ошибки. Конструкторы не подчиняются этим правилам. Правила
      ковариантности/контравариантности также применяются для объединенных и пересеченных типов.

    - ### В видео продемонстрированы примеры ковариантности с использованием интерфейса Приюта для Животных и контравариантности с использованием метода eat(). Объясняется, как соблюдается замена Лискова для контравариантных методов, но она может нарушаться для ковариантных параметров. В целом, видео дает ясное объяснение ковариантности и контравариантности в PHP, демонстрируя, как они позволяют полиморфизм при сохранении типобезопасности.
