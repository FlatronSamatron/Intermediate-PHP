# PHP intermediate
* [PHP Docker - Nginx](https://www.youtube.com/watch?v=I_9-xWmkh28)

  * Рассматриваются такие понятия как контейнеры, образы, Dockerfile и Docker Compose в контексте среды разработки Docker для PHP.

  * Показан простой проект с двумя сервисами - PHP-FPM и Nginx. Используются файлы Dockerfile и docker-compose.yml для конфигурирования контейнеров.

  * С помощью docker-compose можно запустить несколько проектов на разных версиях PHP одновременно. Это упрощает настройку окружения по сравнению с XAMPP.

  *  Также упоминается о дополнительных сервисах как MySQL, о настройке php.ini и нюансах производственной среды.

  *  ### В целом дается представление о Docker для среды разработки PHP-приложений - что такое контейнеры и образы, как писать Dockerfile и docker-compose.yml.
---

* [PHP Classes & Objects - Typed Properties - Constructors & Destructors](https://www.youtube.com/watch?v=6FW72q5fIx8)
  - Класс - это чертеж для создания объектов. Объект - это экземпляр класса.

  - Свойства определяют данные объекта, а методы - его поведение. Видимость может быть публичной, приватной или защищенной.

  - Конструкторы инициализируют свойства при создании объекта. Проверка типов для свойств требует их инициализации.

  - Методы могут возвращать объект, чтобы разрешить цепочку вызовов методов. Не все методы должны быть цепочными.

  - Геттеры и сеттеры используются для энкапсуляции доступа к свойствам, когда они приватные.

  - Можно создать несколько объектов одного класса с разными значениями свойств.

  - Деструкторы выполняют очистку при уничтожении объекта. Они редко используются.

  - StdClass может быть использован для генерического создания объектов. Массивы и скалярные типы могут быть преобразованы в объекты.

  - Свойства объекта соответствуют ключам массива или значениям скалярного типа при преобразовании.

  - Проверка типов для свойств определяет ожидаемый тип, предотвращая недопустимые назначения.

  - ### В резюме видео рассматриваются ключевые концепции классов, объектов, свойств, методов, конструкторов, цепочного вызова и энкапсуляции в объектно-ориентированном программировании PHP. Показано как определять классы и создавать множественные экземпляры объектов.
---
- [Constructor Property Promotion - Nullsafe Operator](https://www.youtube.com/watch?v=T1PbFz-o6kw)
---
- [PHP Namespace Tutorial](https://www.youtube.com/watch?v=Jni9c0-NjrY)
  - Пространства имен помогают избежать коллизий имен классов, функций и констант, логически группируя взаимосвязанные элементы.

  - Ключевое слово namespace используется в верхней части файла для объявления пространства имен. Пространства имен могут содержать подпространства для соответствия древовидной структуре каталогов.

  - Без пространств имен элементы по умолчанию попадают в глобальное пространство имен и могут возникнуть коллизии. Использование пространств имен решает эту проблему.

  - Классы обращаются к своему полностью квалифицированному имени с разделителем пространств имен либо через импорт пространств/классов.

  - Правила разрешения имен - не квалифицированное ищется в локальном пространстве, квалифицированное - по импортам, полностью квалифицированное всегда работает.

  - Функции ищутся в глобальном пространстве если не найдены локально, в отличие от классов, которые выдают ошибку. Функции могут префиксироваться для обеспечения глобальной области видимости.

  - Псевдонимы позволяют использовать одно и то же имя класса из разных пространств имен, избегая коллизий. Можно также полностью переименовать пространство имен.

  - Подключаемые файлы не наследуют импортированные классы/пространства родительского файла, поэтому импорты требуются в обоих.

  - ### Это охватывает основные моменты использования пространств имен для избежания коллизий имен, разрешения пространств и классов, а также некоторые лучшие практики работы с namespaces в PHP.
---
- [PHP Coding Standards, Autoloading (PSR-4) & Composer](https://www.youtube.com/watch?v=rqzYdHdyMH0)
  - В PHP есть встроенная функция автозагрузки классов spl_autoload_register, которая позволяет определить callback-функцию для автоматической загрузки классов.

  - Внутри функции-обработчика получается полное имя класса, на основании которого необходимо подключить/включить соответствующий файл.

  - Composer - это менеджер зависимостей для PHP, который берет на себя автозагрузку и установку внешних пакетов/библиотек.

  - Composer генерирует файлы автозагрузки, в которых классы соотносятся с путями к файлам, позволяя автоматически загружать классы.

  - В composer.json перечисляются зависимости проекта, которые будут устанавливаться с Packagist.

  - Папка vendor содержит исходный код установленных зависимостей. autoload.php регистрирует автозагрузчик Composer.

  - Стандарты PSR такие как PSR-1 и PSR-12 определяют рекомендации по стилю кода PHP-проектов. PHP CodeSniffer проверяет соответствие стилю.

  - Composer может автозагружать классы проекта, если их пространства имен указаны в composer.json и файла автозагрузки пересобраны.

  - Классовая карта (classmap) позволяет для оптимизации прямо соотносить все классы с файлами в продакшене.

  - ### То есть в кратце в видео рассказывалось про автозагрузку классов в PHP, использование Composer для управления зависимостями и автозагрузкой, стандарты PSR, настройку PHP-проекта с применением Composer.
---
- [Object Oriented PHP - Class Constants](https://www.youtube.com/watch?v=bEGNvUxYf2o)
  - Константы в PHP определяются с помощью ключевого слова const и должны быть в верхнем регистре с подчёркиваниями. Они являются неизменяемыми значениями.

  - Классовые константы можно обращаться с использованием имени класса и оператора разрешения области видимости (::). Они выделяются один раз для каждого класса.

  - Константам можно задавать видимость, такую как public или private. Приватные константы можно обращаться только внутри класса.

  - Константы удобны для хранения неизменяемых данных, значение которых может меняться, избегая жёсткого кодирования значений.

  - Константы в стиле enum можно использовать для представления статусов, ролей и т.д., предотвращая ошибки в написании. Они были вынесены из класса Transaction в отдельный класс перечислений Status.

  - Добавлена константа all_statuses в виде массива со статусами в качестве ключей и понятными именами в качестве значений для валидации.

  - Упомянуты статические свойства и методы как следующая тема. PHP 8.1 добавит нативную поддержку типа enum для более чистого определения классов констант.

  - ### В резюме рассказано о том, как определять, обращаться и использовать классовые константы в PHP, а также некоторых лучших практиках, таких как вынесение их в отдельные классы перечислений для организации и валидации.
---
- [Static Properties & Methods + singletone](https://www.youtube.com/watch?v=6VVN-2SCx7Q)

  - Статические свойства и методы принадлежат самому классу, а не отдельным объектам. Их можно обращаться без создания объекта.

  - Чтобы определить статическое свойство/метод, используется ключевое слово static. Свойства можно инициализировать как обычные свойства.

  - Статические свойства общедоступны для всех экземпляров класса. Изменение значения в одном месте влияет на все.

  - Для доступа к приватным статическим свойствам изнутри класса используются ключевые слова self или название класса. Вне класса могут понадобиться статические геттеры.

  - Типичные случаи использования статиков - счётчики, кэширование, утилитные методы, шаблоны singleton/factory (хотя предпочтительнее инъекция зависимостей).

  - Статики представляют глобальное состояние, что ухудшает тестируемость и поддержку. Их следует избегать, кроме очень узких случаев.

  - Статические методы могут маскироваться под методы объекта, но не стоит этого делать, так как это скрывает их статическую природу.

  - ### В видео показано определение/вызов статических свойств и методов, их общее значение, доступ из класса, вред от неправильного использования статиков.
--- 
- [Encapsulation & Abstraction](https://www.youtube.com/watch?v=kA9BTNPFObo)
  - Инкапсуляция объединяет данные и методы, которые работают с этими данными, в пределах класса. Она скрывает внутреннее представление и состояние объекта. Это защищает целостность объекта.

  - Установка свойств как публичных может нарушить инкапсуляцию, позволяя внешнему коду изменять внутреннее состояние объекта.

  - Геттеры и сеттеры иногда используются для выставления свойств при одновременном соблюдении инкапсуляции. Однако они также могут нарушить инкапсуляцию при чрезмерном использовании.

  - В целом лучше делать свойства приватными и передавать данные через конструктор или методы, а не позволять внешнему коду изменять состояние через сеттеры.

  - Абстрагирование скрывает детали реализации, так что пользователям нужно знать только интерфейс (вызываемые методы), а не то, как все работает внутри. Это позволяет гибко менять внутреннюю реализацию, не затрагивая внешний код.

  - Приватные/защищённые свойства и методы могут быть доступны другим объектам того же класса с помощью рефлексии или передачи объектов между методами одного класса.

  - Инкапсуляция сосредоточена на скрытии внутреннего состояния, тогда как абстрагирование — на скрытии деталей реализации от пользователей. Оба принципа помогают достичь слабой связанности и лучшего проектирования.

  - ### В целом текст рассматривает инкапсуляцию и абстрагирование как два основных принципа объектно-ориентированного программирования на PHP, акцентируя внимание на то, как их применять для защиты состояния объекта и гибкости реализации.